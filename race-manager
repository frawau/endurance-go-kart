#!/bin/bash

# GoKartRace Manager
# One script to rule them all - manage services, SSL certificates and deployment modes

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ENV_FILE="$SCRIPT_DIR/.env"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Load environment variables
if [ -f "$ENV_FILE" ]; then
    source "$ENV_FILE"
else
    log_error ".env file not found!"
    exit 1
fi

# Build docker compose profile flags based on current config
get_compose_profiles() {
    local profiles=""
    if [ "${SSL_MODE}" = "acme" ] || [ "${SSL_MODE}" = "letsencrypt" ]; then
        profiles="$profiles --profile ssl-acme"
    fi
    echo "$profiles"
}

# For stop/down we include all profiles so profiled containers are stopped too
get_all_profiles() {
    echo "--profile ssl-acme"
}

show_help() {
    echo "GoKartRace Manager - One Script to Rule Them All"
    echo ""
    echo "Usage: $0 [command]"
    echo ""
    echo "Service Management:"
    echo "  start              Start application (HTTP mode)"
    echo "  stop               Stop all services"
    echo "  restart            Restart services with current configuration"
    echo "  rebuild            Rebuild and restart (use after git pull)"
    echo "  logs               Show service logs"
    echo "  status             Show current configuration and service status"
    echo ""
    echo "SSL Management:"
    echo "  enable-letsencrypt Enable automatic SSL with Let's Encrypt (recommended)"
    echo "  enable-acme        Enable automatic SSL with ZeroSSL"
    echo "  enable-manual      Enable manual SSL (provide your own certificates)"
    echo "  disable-ssl        Disable SSL (HTTP only mode)"
    echo "  generate-cert      Generate SSL certificate (automatic modes only)"
    echo "  install-cert       Install manual SSL certificates"
    echo ""
    echo "Timing Station:"
    echo "  deploy-timing      Install timing station as a systemd service"
    echo "  undeploy-timing    Stop and remove timing station systemd service"
    echo "  timing-status      Show timing station service status"
    echo ""
    echo "NetTag Proxy:"
    echo "  deploy-proxy       Install nettag-proxy as a systemd service"
    echo "  undeploy-proxy     Stop and remove nettag-proxy systemd service"
    echo "  proxy-status       Show nettag-proxy service status"
    echo ""
    echo "Test Data Management:"
    echo "  manage <command>   Run Django management command (e.g., generate_test_data)"
    echo ""
    echo "Utility:"
    echo "  generate-secret    Generate secure random secrets for .env file"
    echo "  configure-stations Write .env values (hostname, HMAC secrets) into station TOML files"
    echo "  help               Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 start                    # Start in HTTP mode"
    echo "  $0 enable-letsencrypt       # Configure Let's Encrypt SSL"
    echo "  $0 generate-cert            # Generate certificate"
    echo "  $0 generate-secret          # Generate SECRET_KEY and HMAC secrets"
    echo "  $0 rebuild                  # Rebuild after git pull"
    echo "  $0 deploy-timing            # Install timing station as native service"
    echo "  $0 deploy-proxy             # Install nettag-proxy systemd service"
    echo "  $0 manage generate_test_data --teams 50  # Generate test data"
    echo ""
}

show_status() {
    log_info "Current SSL Configuration:"
    echo "  SSL_MODE: ${SSL_MODE:-none (commented out)}"
    echo "  APP_HOSTNAME: ${APP_HOSTNAME:-not set}"
    echo "  SSL_EMAIL: ${SSL_EMAIL:-not set}"

    if [ -f "ssl/fullchain.pem" ] && [ -f "ssl/privkey.pem" ]; then
        log_success "SSL certificates found in ./ssl/"
    else
        log_warning "No SSL certificates found in ./ssl/"
    fi

    # Check if acme.sh service is running
    if docker ps | grep -q acme_sh; then
        log_success "acme.sh service is running"
    else
        log_info "acme.sh service is not running"
    fi

    echo ""
    log_info "Timing Station:"
    if systemctl is-active --quiet timing-station 2>/dev/null; then
        log_success "Timing station service is running"
        echo "  TIMING_PLUGIN_TYPE: ${TIMING_PLUGIN_TYPE:-simulator}"
        echo "  TIMING_MODE: ${TIMING_MODE:-duration}"
    else
        log_info "Timing station service is not running"
        log_info "Deploy with: $0 deploy-timing"
    fi
}

enable_letsencrypt() {
    log_info "Enabling automatic SSL with Let's Encrypt..."

    # Update .env file
    sed -i 's/^# SSL_MODE=.*/SSL_MODE=letsencrypt/' "$ENV_FILE"
    sed -i 's/^SSL_MODE=.*/SSL_MODE=letsencrypt/' "$ENV_FILE"
    sed -i 's/^# SSL_EMAIL=.*/SSL_EMAIL='"${SSL_EMAIL:-admin@$APP_HOSTNAME}"'/' "$ENV_FILE"

    log_success "SSL mode set to 'letsencrypt'"
    log_info "To apply changes, run: $0 restart"
    log_info "To generate certificate, run: $0 generate-cert"
}

enable_acme() {
    log_info "Enabling automatic SSL with ZeroSSL..."
    log_warning "Note: ZeroSSL requires email registration first"
    log_info "For easier setup, use: $0 enable-letsencrypt"

    # Update .env file
    sed -i 's/^# SSL_MODE=.*/SSL_MODE=acme/' "$ENV_FILE"
    sed -i 's/^SSL_MODE=.*/SSL_MODE=acme/' "$ENV_FILE"
    sed -i 's/^# SSL_EMAIL=.*/SSL_EMAIL='"${SSL_EMAIL:-admin@$APP_HOSTNAME}"'/' "$ENV_FILE"

    log_success "SSL mode set to 'acme' (ZeroSSL)"
    log_info "To apply changes, run: $0 restart"
    log_info "To generate certificate, run: $0 generate-cert"
}

enable_manual() {
    log_info "Enabling manual SSL..."

    # Update .env file
    sed -i 's/^# SSL_MODE=.*/SSL_MODE=manual/' "$ENV_FILE"
    sed -i 's/^# SSL_EMAIL=.*/SSL_EMAIL='"${SSL_EMAIL:-admin@$APP_HOSTNAME}"'/' "$ENV_FILE"

    log_success "SSL mode set to 'manual'"
    log_warning "You need to provide SSL certificates in ./ssl/ directory"
    log_info "Required files: ./ssl/fullchain.pem and ./ssl/privkey.pem"
    log_info "To install certificates, run: $0 install-cert"
}

disable_ssl() {
    log_info "Disabling SSL..."

    # Comment out SSL configuration in .env
    sed -i 's/^SSL_MODE=.*$/# SSL_MODE=none/' "$ENV_FILE"
    sed -i 's/^SSL_EMAIL=.*$/# SSL_EMAIL=admin@your-domain.com/' "$ENV_FILE"
    sed -i 's/^ACME_CHALLENGE=.*$/# ACME_CHALLENGE=http/' "$ENV_FILE"

    log_success "SSL disabled"
    log_info "To apply changes, run: $0 restart"
}

start_services() {
    log_info "Starting GoKartRace application..."

    # Set HTTP_PORT based on SSL_MODE
    if [ "${SSL_MODE}" = "none" ] || [ -z "${SSL_MODE}" ]; then
        # HTTP-only mode: use custom port
        export HTTP_PORT=${APP_PORT:-5085}
        log_info "Starting in HTTP-only mode on port ${HTTP_PORT}"
    else
        # SSL mode: must use port 80 for ACME challenge
        export HTTP_PORT=80
        log_info "Starting with SSL support (requires port 80)"
    fi

    local profiles
    profiles=$(get_compose_profiles)
    docker compose $profiles up -d
    log_success "Services started!"

    if [ "${HTTP_PORT}" = "80" ]; then
        log_info "Application available at: http://${APP_HOSTNAME}"
    else
        log_info "Application available at: http://${APP_HOSTNAME}:${HTTP_PORT}"
    fi

}

stop_services() {
    log_info "Stopping all services..."
    docker compose $(get_all_profiles) down
    log_success "All services stopped!"
}

show_logs() {
    log_info "Showing service logs (press Ctrl+C to exit)..."
    docker compose logs -f
}

generate_cert() {
    if [ "${SSL_MODE}" != "acme" ] && [ "${SSL_MODE}" != "letsencrypt" ]; then
        log_error "Certificate generation only available in automatic SSL modes"
        log_info "Run '$0 enable-letsencrypt' or '$0 enable-acme' first"
        log_info "Current SSL_MODE: ${SSL_MODE:-not set}"
        exit 1
    fi

    if [ -z "${SSL_EMAIL}" ]; then
        log_error "SSL_EMAIL not set in .env file"
        log_info "Please add: SSL_EMAIL=your-email@example.com"
        exit 1
    fi

    # SSL modes require port 80 for ACME challenge
    export HTTP_PORT=80
    log_info "Using port 80 for ACME HTTP-01 challenge"

    log_info "Starting services with acme.sh profile..."
    docker compose --profile ssl-acme up -d

    log_info "Waiting for services to start..."
    sleep 5

    # Configure CA based on SSL_MODE
    if [ "${SSL_MODE}" = "letsencrypt" ]; then
        log_info "Configuring acme.sh to use Let's Encrypt..."
        docker compose exec acme-sh acme.sh --set-default-ca --server letsencrypt

        log_info "Registering account with Let's Encrypt (${SSL_EMAIL})..."
        docker compose exec acme-sh acme.sh --register-account -m "${SSL_EMAIL}"
    elif [ "${SSL_MODE}" = "acme" ]; then
        log_info "Configuring acme.sh to use ZeroSSL (default)..."
        log_info "Registering account with ZeroSSL (${SSL_EMAIL})..."
        docker compose exec acme-sh acme.sh --register-account -m "${SSL_EMAIL}"
    fi

    log_info "Generating SSL certificate for ${APP_HOSTNAME}..."
    docker compose exec acme-sh acme.sh --issue -d "${APP_HOSTNAME}" --webroot /var/www/certbot

    if [ $? -eq 0 ]; then
        log_info "Installing certificate..."
        docker compose exec acme-sh acme.sh --install-cert -d "${APP_HOSTNAME}" \
            --cert-file /etc/ssl/certs/cert.pem \
            --key-file /etc/ssl/certs/privkey.pem \
            --fullchain-file /etc/ssl/certs/fullchain.pem

        log_success "SSL certificate generated and installed!"
        log_info "Restarting nginx to enable HTTPS..."
        docker compose restart nginx

        if [ "${SSL_MODE}" = "letsencrypt" ]; then
            log_success "HTTPS is now enabled at https://${APP_HOSTNAME} (Let's Encrypt)"
        else
            log_success "HTTPS is now enabled at https://${APP_HOSTNAME} (ZeroSSL)"
        fi
    else
        log_error "Certificate generation failed!"
        log_info "Check that:"
        log_info "  - ${APP_HOSTNAME} points to this server"
        log_info "  - Port 80 is accessible from the internet"
        log_info "  - No firewall is blocking the connection"
        log_info "  - DNS propagation is complete (try: nslookup ${APP_HOSTNAME})"
        exit 1
    fi
}

install_cert() {
    log_info "Installing manual SSL certificates..."

    if [ ! -f "ssl/fullchain.pem" ] || [ ! -f "ssl/privkey.pem" ]; then
        log_error "SSL certificates not found!"
        log_info "Please place your certificates in:"
        log_info "  ./ssl/fullchain.pem"
        log_info "  ./ssl/privkey.pem"
        exit 1
    fi

    # Copy certificates to docker volume
    docker run --rm -v "$(pwd)/ssl:/source" -v "ssl_certs:/dest" alpine \
        sh -c "cp /source/*.pem /dest/"

    log_success "SSL certificates installed!"
    log_info "Restarting services..."
    docker compose restart nginx
}

restart_services() {
    log_info "Restarting services with current configuration..."

    # Set HTTP_PORT based on SSL_MODE
    if [ "${SSL_MODE}" = "none" ] || [ -z "${SSL_MODE}" ]; then
        export HTTP_PORT=${APP_PORT:-5085}
        log_info "Using custom port ${HTTP_PORT}"
    else
        export HTTP_PORT=80
        log_info "Using standard port 80 (required for SSL)"
    fi

    local profiles
    profiles=$(get_compose_profiles)
    docker compose $(get_all_profiles) down
    docker compose $profiles up -d

    log_success "Services restarted!"
}

rebuild_services() {
    log_info "Rebuilding and restarting services..."
    log_warning "This will rebuild the Docker image (use after git pull or code changes)"

    # Set HTTP_PORT based on SSL_MODE
    if [ "${SSL_MODE}" = "none" ] || [ -z "${SSL_MODE}" ]; then
        export HTTP_PORT=${APP_PORT:-5085}
        log_info "Using custom port ${HTTP_PORT}"
    else
        export HTTP_PORT=80
        log_info "Using standard port 80 (required for SSL)"
    fi

    local profiles
    profiles=$(get_compose_profiles)
    docker compose $(get_all_profiles) down
    docker compose $profiles build
    docker image prune -f
    docker compose $profiles up -d

    log_success "Services rebuilt and restarted!"
}

generate_secret() {
    log_info "Generating secure random secrets..."
    echo ""

    # Generate secrets
    SECRET_KEY=$(openssl rand -base64 64 | tr -d '\n')
    HMAC_SECRET=$(openssl rand -base64 64 | tr -d '\n')
    TIMING_SECRET=$(openssl rand -base64 64 | tr -d '\n')

    # Display generated secrets
    log_info "Generated secrets:"
    echo "  SECRET_KEY: ${GREEN}${SECRET_KEY}${NC}"
    echo "  STOPANDGO_HMAC_SECRET: ${GREEN}${HMAC_SECRET}${NC}"
    echo "  TIMING_HMAC_SECRET: ${GREEN}${TIMING_SECRET}${NC}"
    echo ""

    # Update .env file
    if [ -f "$ENV_FILE" ]; then
        log_info "Updating $ENV_FILE..."

        # Update or add SECRET_KEY
        if grep -q "^SECRET_KEY=" "$ENV_FILE"; then
            sed -i "s|^SECRET_KEY=.*|SECRET_KEY=${SECRET_KEY}|" "$ENV_FILE"
        elif grep -q "^# SECRET_KEY=" "$ENV_FILE"; then
            sed -i "s|^# SECRET_KEY=.*|SECRET_KEY=${SECRET_KEY}|" "$ENV_FILE"
        else
            echo "SECRET_KEY=${SECRET_KEY}" >> "$ENV_FILE"
        fi

        # Update or add STOPANDGO_HMAC_SECRET
        if grep -q "^STOPANDGO_HMAC_SECRET=" "$ENV_FILE"; then
            sed -i "s|^STOPANDGO_HMAC_SECRET=.*|STOPANDGO_HMAC_SECRET=${HMAC_SECRET}|" "$ENV_FILE"
        elif grep -q "^# STOPANDGO_HMAC_SECRET=" "$ENV_FILE"; then
            sed -i "s|^# STOPANDGO_HMAC_SECRET=.*|STOPANDGO_HMAC_SECRET=${HMAC_SECRET}|" "$ENV_FILE"
        else
            echo "STOPANDGO_HMAC_SECRET=${HMAC_SECRET}" >> "$ENV_FILE"
        fi

        # Update or add TIMING_HMAC_SECRET
        if grep -q "^TIMING_HMAC_SECRET=" "$ENV_FILE"; then
            sed -i "s|^TIMING_HMAC_SECRET=.*|TIMING_HMAC_SECRET=${TIMING_SECRET}|" "$ENV_FILE"
        elif grep -q "^# TIMING_HMAC_SECRET=" "$ENV_FILE"; then
            sed -i "s|^# TIMING_HMAC_SECRET=.*|TIMING_HMAC_SECRET=${TIMING_SECRET}|" "$ENV_FILE"
        else
            echo "TIMING_HMAC_SECRET=${TIMING_SECRET}" >> "$ENV_FILE"
        fi

        log_success "Secrets updated in $ENV_FILE"
    else
        log_error ".env file not found at $ENV_FILE"
        log_info "Please create .env file first or run this from the project directory"
        exit 1
    fi

    echo ""
    log_warning "IMPORTANT: Keep these secrets secure and never commit them to version control!"
    log_info "For Stop & Go station: Configure the same STOPANDGO_HMAC_SECRET on your Raspberry Pi hardware"
    log_info "Restart services to apply the new secrets: $0 restart"

    # Propagate secrets to station TOML files
    # Re-source .env so the newly written values are available
    source "$ENV_FILE"
    configure_stations
}

configure_stations() {
    log_info "Configuring station TOML files from .env values..."

    local stopandgo_toml="$SCRIPT_DIR/stations/stopandgo/stopandgo-station.toml"
    local timing_toml="$SCRIPT_DIR/stations/timing/timing-station.toml"
    local missing=0

    if [ -z "${APP_HOSTNAME:-}" ]; then
        log_warning "APP_HOSTNAME is not set in .env — skipping hostname substitution"
        missing=1
    fi
    if [ -z "${STOPANDGO_HMAC_SECRET:-}" ]; then
        log_warning "STOPANDGO_HMAC_SECRET is not set in .env — skipping stop-and-go HMAC substitution"
        missing=1
    fi
    if [ -z "${TIMING_HMAC_SECRET:-}" ]; then
        log_warning "TIMING_HMAC_SECRET is not set in .env — skipping timing HMAC substitution"
        missing=1
    fi

    # Stop-and-go station
    if [ -f "$stopandgo_toml" ]; then
        if [ -n "${APP_HOSTNAME:-}" ]; then
            sed -i "s|^server = .*|server = \"${APP_HOSTNAME}\"|" "$stopandgo_toml"
        fi
        if [ -n "${STOPANDGO_HMAC_SECRET:-}" ]; then
            sed -i "s|^hmac_secret = .*|hmac_secret = \"${STOPANDGO_HMAC_SECRET}\"|" "$stopandgo_toml"
        fi
        if [ -n "${STOPANDGO_PORT:-}" ]; then
            sed -i "s|^port = .*|port = ${STOPANDGO_PORT}|" "$stopandgo_toml"
        fi
        if [ -n "${STOPANDGO_SECURE:-}" ]; then
            sed -i "s|^secure = .*|secure = ${STOPANDGO_SECURE}|" "$stopandgo_toml"
        fi
        if [ -n "${STOPANDGO_LOG_LEVEL:-}" ]; then
            sed -i "s|^level = .*|level = \"${STOPANDGO_LOG_LEVEL}\"|" "$stopandgo_toml"
        fi
        log_success "Updated $stopandgo_toml"
    else
        log_warning "Stop-and-go config not found at $stopandgo_toml"
    fi

    # Timing station
    if [ -f "$timing_toml" ]; then
        # [daemon] section — keys are unique, safe to match globally
        if [ -n "${APP_HOSTNAME:-}" ]; then
            local ws_port="${APP_PORT:-5085}"
            if [ "${SSL_MODE}" != "none" ] && [ -n "${SSL_MODE:-}" ]; then
                ws_port=80
            fi
            sed -i "s|^websocket_url = .*|websocket_url = \"ws://127.0.0.1:${ws_port}/ws/timing/\"|" "$timing_toml"
        fi
        if [ -n "${TIMING_HMAC_SECRET:-}" ]; then
            sed -i "s|^hmac_secret = .*|hmac_secret = \"${TIMING_HMAC_SECRET}\"|" "$timing_toml"
        fi
        if [ -n "${TIMING_MODE:-}" ]; then
            sed -i "s|^timing_mode = .*|timing_mode = \"${TIMING_MODE}\"|" "$timing_toml"
        fi
        if [ -n "${TIMING_ROLLOVER_SECONDS:-}" ]; then
            sed -i "s|^rollover_seconds = .*|rollover_seconds = ${TIMING_ROLLOVER_SECONDS}|" "$timing_toml"
        fi

        # [plugin] section — "type" is unique to this section
        if [ -n "${TIMING_PLUGIN_TYPE:-}" ]; then
            sed -i "s|^type = .*|type = \"${TIMING_PLUGIN_TYPE}\"|" "$timing_toml"
        fi

        # [plugin.nettag] — "host", "port", "protocol" need section-aware replacement
        if [ -n "${TIMING_NETTAG_HOST:-}" ]; then
            sed -i "/^\[plugin\.nettag\]/,/^\[/ s|^host = .*|host = \"${TIMING_NETTAG_HOST}\"|" "$timing_toml"
        fi
        if [ -n "${TIMING_NETTAG_PORT:-}" ]; then
            sed -i "/^\[plugin\.nettag\]/,/^\[/ s|^port = .*|port = ${TIMING_NETTAG_PORT}|" "$timing_toml"
        fi
        if [ -n "${TIMING_NETTAG_PROTOCOL:-}" ]; then
            sed -i "/^\[plugin\.nettag\]/,/^\[/ s|^protocol = .*|protocol = \"${TIMING_NETTAG_PROTOCOL}\"|" "$timing_toml"
        fi

        # [plugin.tag]
        if [ -n "${TIMING_TAG_DEVICE:-}" ]; then
            sed -i "/^\[plugin\.tag\]/,/^\[/ s|^device = .*|device = \"${TIMING_TAG_DEVICE}\"|" "$timing_toml"
        fi
        if [ -n "${TIMING_TAG_BAUD:-}" ]; then
            sed -i "/^\[plugin\.tag\]/,/^\[/ s|^baud = .*|baud = ${TIMING_TAG_BAUD}|" "$timing_toml"
        fi

        # [plugin.simulator]
        if [ -n "${TIMING_SIM_TRANSPONDERS:-}" ]; then
            sed -i "s|^num_transponders = .*|num_transponders = ${TIMING_SIM_TRANSPONDERS}|" "$timing_toml"
        fi
        if [ -n "${TIMING_SIM_LAP_MIN:-}" ]; then
            sed -i "s|^lap_time_min = .*|lap_time_min = ${TIMING_SIM_LAP_MIN}|" "$timing_toml"
        fi
        if [ -n "${TIMING_SIM_LAP_MAX:-}" ]; then
            sed -i "s|^lap_time_max = .*|lap_time_max = ${TIMING_SIM_LAP_MAX}|" "$timing_toml"
        fi

        log_success "Updated $timing_toml"
    else
        log_warning "Timing config not found at $timing_toml"
    fi

    if [ "$missing" -eq 0 ]; then
        log_success "All station configs updated successfully"
    else
        log_warning "Some values were missing — re-run after populating .env"
    fi
}

deploy_proxy() {
    log_info "Deploying nettag-proxy as a systemd service..."

    PROXY_DIR="$SCRIPT_DIR/proxy"
    SERVICE_TEMPLATE="$PROXY_DIR/nettag-proxy.service.template"
    SERVICE_FILE="/etc/systemd/system/nettag-proxy.service"
    STATE_DIR="/var/lib/nettag-proxy"

    if [ ! -f "$SERVICE_TEMPLATE" ]; then
        log_error "Service template not found at $SERVICE_TEMPLATE"
        exit 1
    fi

    if [ ! -f "$PROXY_DIR/nettag-proxy.toml" ]; then
        log_error "Config file not found at $PROXY_DIR/nettag-proxy.toml"
        log_info "Copy and edit the example: cp proxy/nettag-proxy.toml proxy/nettag-proxy.toml"
        exit 1
    fi

    # Detect current user/group
    PROXY_USER="${SUDO_USER:-$(whoami)}"
    PROXY_GROUP="$(id -gn "$PROXY_USER")"

    log_info "Installing service as user=$PROXY_USER group=$PROXY_GROUP"
    log_info "Working directory: $PROXY_DIR"

    # Create state directory for SQLite buffer
    sudo mkdir -p "$STATE_DIR"
    sudo chown "$PROXY_USER:$PROXY_GROUP" "$STATE_DIR"

    # Generate service file from template
    sed \
        -e "s|__USER__|$PROXY_USER|g" \
        -e "s|__GROUP__|$PROXY_GROUP|g" \
        -e "s|__WORKDIR__|$SCRIPT_DIR|g" \
        "$SERVICE_TEMPLATE" | sudo tee "$SERVICE_FILE" > /dev/null

    # Ensure the proxy script is executable
    chmod +x "$PROXY_DIR/nettag-proxy"

    sudo systemctl daemon-reload
    sudo systemctl enable nettag-proxy
    sudo systemctl start nettag-proxy

    log_success "nettag-proxy service deployed and started!"
    log_info "Config: $PROXY_DIR/nettag-proxy.toml"
    log_info "Buffer: $STATE_DIR/nettag_buffer.db"
    log_info "Check status: $0 proxy-status"
    log_info "View logs: journalctl -u nettag-proxy -f"
}

undeploy_proxy() {
    log_info "Removing nettag-proxy systemd service..."

    sudo systemctl stop nettag-proxy 2>/dev/null || true
    sudo systemctl disable nettag-proxy 2>/dev/null || true
    sudo rm -f /etc/systemd/system/nettag-proxy.service
    sudo systemctl daemon-reload

    log_success "nettag-proxy service removed"
    log_info "Buffer data preserved in /var/lib/nettag-proxy/"
    log_info "To remove buffer: sudo rm -rf /var/lib/nettag-proxy"
}

deploy_timing() {
    log_info "Deploying timing station as a systemd service..."

    TIMING_DIR="$SCRIPT_DIR/stations/timing"
    SERVICE_TEMPLATE="$TIMING_DIR/timing-station.service.template"
    SERVICE_FILE="/etc/systemd/system/timing-station.service"
    STATE_DIR="/var/lib/timing-station"
    VENV_DIR="$TIMING_DIR/venv"

    if [ ! -f "$SERVICE_TEMPLATE" ]; then
        log_error "Service template not found at $SERVICE_TEMPLATE"
        exit 1
    fi

    # Detect current user/group
    TIMING_USER="${SUDO_USER:-$(whoami)}"
    TIMING_GROUP="$(id -gn "$TIMING_USER")"

    log_info "Installing service as user=$TIMING_USER group=$TIMING_GROUP"

    # Create venv if it doesn't exist
    if [ ! -d "$VENV_DIR" ]; then
        log_info "Creating Python virtual environment at $VENV_DIR..."
        python3 -m venv "$VENV_DIR"
        chown -R "$TIMING_USER:$TIMING_GROUP" "$VENV_DIR"
    fi

    # Install dependencies
    log_info "Installing dependencies..."
    "$VENV_DIR/bin/pip" install --quiet -r "$TIMING_DIR/requirements.txt"

    # Generate timing-station.toml from .env values
    log_info "Generating timing-station.toml from .env..."
    configure_stations

    # Create state directory
    sudo mkdir -p "$STATE_DIR"
    sudo chown "$TIMING_USER:$TIMING_GROUP" "$STATE_DIR"

    # Generate service file from template
    sed \
        -e "s|__USER__|$TIMING_USER|g" \
        -e "s|__GROUP__|$TIMING_GROUP|g" \
        -e "s|__WORKDIR__|$SCRIPT_DIR|g" \
        "$SERVICE_TEMPLATE" | sudo tee "$SERVICE_FILE" > /dev/null

    sudo systemctl daemon-reload
    sudo systemctl enable timing-station
    sudo systemctl start timing-station

    log_success "Timing station service deployed and started!"
    log_info "Config: $TIMING_DIR/timing-station.toml"
    log_info "Check status: $0 timing-status"
    log_info "View logs: journalctl -u timing-station -f"
}

undeploy_timing() {
    log_info "Removing timing station systemd service..."

    sudo systemctl stop timing-station 2>/dev/null || true
    sudo systemctl disable timing-station 2>/dev/null || true
    sudo rm -f /etc/systemd/system/timing-station.service
    sudo systemctl daemon-reload

    log_success "Timing station service removed"
    log_info "Venv preserved at $SCRIPT_DIR/stations/timing/venv"
    log_info "Buffer data preserved in /var/lib/timing-station/"
}

timing_status() {
    if systemctl is-active --quiet timing-station 2>/dev/null; then
        log_success "timing-station is running"
    else
        log_warning "timing-station is not running"
    fi
    systemctl status timing-station --no-pager 2>/dev/null || true
}

proxy_status() {
    if systemctl is-active --quiet nettag-proxy 2>/dev/null; then
        log_success "nettag-proxy is running"
    else
        log_warning "nettag-proxy is not running"
    fi
    systemctl status nettag-proxy --no-pager 2>/dev/null || true
}

# Main command handling
case "${1:-help}" in
    "start")
        start_services
        ;;
    "stop")
        stop_services
        ;;
    "restart")
        restart_services
        ;;
    "rebuild")
        rebuild_services
        ;;
    "manage")
        # Run Django management command
        # Shift to remove 'manage' from arguments, leaving the actual command
        shift
        if [ -z "$1" ]; then
            log_error "No management command specified"
            log_info "Usage: $0 manage <command> [args]"
            log_info "Example: $0 manage generate_test_data --teams 50"
            exit 1
        fi
        log_info "Running Django management command: python manage.py $*"
        docker compose exec appseed-app python manage.py "$@"
        ;;
    "logs")
        show_logs
        ;;
    "status")
        show_status
        ;;
    "enable-letsencrypt")
        enable_letsencrypt
        ;;
    "enable-acme")
        enable_acme
        ;;
    "enable-manual")
        enable_manual
        ;;
    "disable-ssl")
        disable_ssl
        ;;
    "generate-cert")
        generate_cert
        ;;
    "install-cert")
        install_cert
        ;;
    "generate-secret")
        generate_secret
        ;;
    "configure-stations")
        configure_stations
        ;;
    "deploy-timing")
        deploy_timing
        ;;
    "undeploy-timing")
        undeploy_timing
        ;;
    "timing-status")
        timing_status
        ;;
    "deploy-proxy")
        deploy_proxy
        ;;
    "undeploy-proxy")
        undeploy_proxy
        ;;
    "proxy-status")
        proxy_status
        ;;
    "help"|*)
        show_help
        ;;
esac